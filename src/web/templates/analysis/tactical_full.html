{% extends "base.html" %}

{% block title %}Taktische Ansicht - Vollständige Analyse{% endblock %}

{% block head %}
<style>
    .tactical-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        height: calc(100vh - 220px);
    }

    @media (max-width: 1200px) {
        .tactical-container {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr;
        }
    }

    .video-panel, .field-panel {
        background: #1F2937;
        border-radius: 0.5rem;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .panel-header {
        background: #374151;
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .panel-content {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
        padding: 10px;
    }

    #videoPlayer {
        max-width: 100%;
        max-height: 100%;
    }

    .field-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #fieldSvg {
        max-width: 100%;
        max-height: 100%;
        border-radius: 8px;
    }

    #playersOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .controls {
        background: #374151;
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .timeline {
        flex: 1;
        height: 8px;
        background: #4B5563;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
    }

    .timeline-progress {
        height: 100%;
        background: #3B82F6;
        border-radius: 4px;
        width: 0%;
    }

    .legend {
        display: flex;
        gap: 1rem;
        align-items: center;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.75rem;
    }

    .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid white;
    }

    .speed-btn {
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        background: transparent;
        border: 1px solid #6B7280;
        color: #D1D5DB;
        cursor: pointer;
    }

    .speed-btn.active {
        background: #3B82F6;
        border-color: #3B82F6;
        color: white;
    }

    .info-panel {
        background: #1F2937;
        border-radius: 0.5rem;
        padding: 1rem;
        margin-top: 1rem;
    }

    .chunk-indicator {
        display: flex;
        gap: 2px;
        margin-top: 0.5rem;
    }

    .chunk-bar {
        height: 4px;
        flex: 1;
        background: #4B5563;
        border-radius: 2px;
    }

    .chunk-bar.active {
        background: #3B82F6;
    }

    .chunk-bar.loaded {
        background: #10B981;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-6" style="max-width: 1800px;">
    <!-- Header -->
    <div class="flex items-center justify-between mb-4">
        <div>
            <a href="/analysis/video/{{ video.id }}" class="text-blue-500 hover:underline text-sm">
                &larr; Zurück zur Analyse
            </a>
            <h1 class="text-xl font-bold mt-1 text-white">Taktische Ansicht: {{ video.filename }}</h1>
            <p class="text-sm text-gray-400">
                Vollständige Spielanalyse - {{ periods|length }} Spielzeit(en), {{ chunks|length }} Chunks
            </p>
        </div>
        <div class="flex items-center gap-4">
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: {{ team_config.team1.displayColor }};"></div>
                    <span class="text-gray-300">Team 1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: {{ team_config.team2.displayColor }};"></div>
                    <span class="text-gray-300">Team 2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: {{ team_config.referee.displayColor }}; width: 10px; height: 10px;"></div>
                    <span class="text-gray-300">Schiri</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Tactical View -->
    <div class="tactical-container">
        <!-- Video Panel -->
        <div class="video-panel">
            <div class="panel-header">
                <h2 class="text-white font-medium">Video</h2>
                <div class="flex items-center gap-4">
                    <label class="flex items-center gap-2 text-gray-300 text-sm cursor-pointer">
                        <input type="checkbox" id="showVideoOverlay" checked class="form-checkbox">
                        Tracking
                    </label>
                    <span id="videoTime" class="text-gray-400 text-sm font-mono">00:00.0</span>
                </div>
            </div>
            <div class="panel-content bg-black">
                <div class="video-wrapper" style="position: relative; display: inline-block;">
                    <video id="videoPlayer" preload="auto">
                        <source src="/api/videos/{{ video.id }}/stream" type="video/mp4">
                    </video>
                    <canvas id="videoOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                </div>
            </div>
        </div>

        <!-- Field Panel -->
        <div class="field-panel">
            <div class="panel-header">
                <h2 class="text-white font-medium">Spielfeld (40m x 20m)</h2>
                <span id="frameInfo" class="text-gray-400 text-sm">Chunk: -</span>
            </div>
            <div class="panel-content" id="fieldContainer">
                <div class="field-wrapper">
                    <img id="fieldSvg" src="/static/images/Floorball_rink1.svg" alt="Floorball Spielfeld">
                    <svg id="playersOverlay" viewBox="0 0 40 20" preserveAspectRatio="xMidYMid meet">
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls mt-4 rounded-lg">
        <button id="playPauseBtn" class="bg-white text-gray-900 px-4 py-2 rounded font-medium">
            Play
        </button>

        <div class="timeline" id="timeline">
            <div class="timeline-progress" id="timelineProgress"></div>
        </div>

        <span id="currentTime" class="text-white font-mono text-sm">00:00.0</span>
        <span class="text-gray-500">/</span>
        <span id="duration" class="text-white font-mono text-sm">00:00.0</span>

        <div class="flex gap-1">
            <button class="speed-btn" data-speed="0.25">0.25x</button>
            <button class="speed-btn" data-speed="0.5">0.5x</button>
            <button class="speed-btn active" data-speed="1">1x</button>
            <button class="speed-btn" data-speed="2">2x</button>
        </div>

        <div class="flex items-center gap-2">
            <label class="text-gray-300 text-sm">Trail:</label>
            <input type="range" id="trailLength" min="0" max="20" value="5" class="w-20">
            <span id="trailValue" class="text-gray-400 text-sm">5</span>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div class="flex justify-between items-center">
            <div>
                <span class="text-gray-400 text-sm">Aktueller Chunk:</span>
                <span id="currentChunk" class="text-white font-mono ml-2">-</span>
            </div>
            <div>
                <span class="text-gray-400 text-sm">Geladene Daten:</span>
                <span id="loadedChunks" class="text-green-400 font-mono ml-2">0</span>
                <span class="text-gray-500">/</span>
                <span class="text-white font-mono">{{ chunks|length }}</span>
            </div>
        </div>
        <div class="chunk-indicator" id="chunkIndicator">
            {% for chunk in chunks %}
            <div class="chunk-bar" data-chunk="{{ chunk.chunk_index }}" title="Chunk {{ chunk.chunk_index + 1 }}: {{ chunk.start_time|round(1) }}s - {{ chunk.end_time|round(1) }}s"></div>
            {% endfor %}
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
const videoId = "{{ video.id }}";
const calibrationId = "{{ calibration.id if calibration else '' }}";
const teamConfig = {{ team_config | tojson | safe }};
const totalDuration = {{ total_duration }};

// Chunk-Informationen
const chunks = [
    {% for chunk in chunks %}
    {
        index: {{ chunk.chunk_index }},
        start: {{ chunk.start_time }},
        end: {{ chunk.end_time }},
        loaded: false,
        data: null
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];

// Floorball Spielfeld-Dimensionen
const FIELD_LENGTH = 40;
const FIELD_WIDTH = 20;

const video = document.getElementById('videoPlayer');
const playersOverlay = document.getElementById('playersOverlay');
const playPauseBtn = document.getElementById('playPauseBtn');
const timeline = document.getElementById('timeline');
const timelineProgress = document.getElementById('timelineProgress');
const currentTimeEl = document.getElementById('currentTime');
const durationEl = document.getElementById('duration');
const videoTimeEl = document.getElementById('videoTime');
const frameInfoEl = document.getElementById('frameInfo');
const trailLengthInput = document.getElementById('trailLength');
const trailValueEl = document.getElementById('trailValue');

let currentChunkIndex = -1;
let trailLength = 5;
let positionHistory = {};
let showVideoOverlay = true;

// Video Overlay Canvas
const videoOverlay = document.getElementById('videoOverlay');
const videoCtx = videoOverlay.getContext('2d');

function setupVideoOverlay() {
    const updateCanvasSize = () => {
        if (video.videoWidth && video.videoHeight) {
            videoOverlay.width = video.videoWidth;
            videoOverlay.height = video.videoHeight;
        }
    };
    video.addEventListener('loadedmetadata', updateCanvasSize);
    updateCanvasSize();
}

function setupOverlay() {
    const fieldImg = document.getElementById('fieldSvg');
    const wrapper = fieldImg.parentElement;

    const updateOverlayPosition = () => {
        const imgRect = fieldImg.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();

        playersOverlay.style.left = (imgRect.left - wrapperRect.left) + 'px';
        playersOverlay.style.top = (imgRect.top - wrapperRect.top) + 'px';
        playersOverlay.style.width = imgRect.width + 'px';
        playersOverlay.style.height = imgRect.height + 'px';
    };

    fieldImg.onload = updateOverlayPosition;
    window.addEventListener('resize', updateOverlayPosition);
    updateOverlayPosition();
}

// Chunk für aktuelle Zeit finden
function findChunkForTime(time) {
    for (let i = 0; i < chunks.length; i++) {
        if (time >= chunks[i].start && time < chunks[i].end) {
            return i;
        }
    }
    return -1;
}

// Chunk-Daten laden
async function loadChunkData(chunkIndex) {
    if (chunkIndex < 0 || chunkIndex >= chunks.length) return;
    if (chunks[chunkIndex].loaded) return;

    try {
        const chunk = chunks[chunkIndex];
        const response = await fetch(`/analysis/api/videos/${videoId}/chunk-positions/${chunk.index}`);

        if (response.ok) {
            const data = await response.json();
            chunks[chunkIndex].data = data;
            chunks[chunkIndex].loaded = true;

            // UI aktualisieren
            const bar = document.querySelector(`.chunk-bar[data-chunk="${chunk.index}"]`);
            if (bar) bar.classList.add('loaded');

            const loadedCount = chunks.filter(c => c.loaded).length;
            document.getElementById('loadedChunks').textContent = loadedCount;

            console.log(`Chunk ${chunkIndex} loaded: ${data.frames?.length || 0} frames`);
        }
    } catch (e) {
        console.error(`Error loading chunk ${chunkIndex}:`, e);
    }
}

// Vorladen benachbarter Chunks
async function preloadNearbyChunks(currentIndex) {
    // Aktuellen und nächsten Chunk laden
    await loadChunkData(currentIndex);
    if (currentIndex + 1 < chunks.length) {
        loadChunkData(currentIndex + 1);
    }
}

function getTeamColor(team, alpha = 1) {
    let color;
    if (team === 'team1') {
        color = teamConfig.team1?.displayColor || '#3B82F6';
    } else if (team === 'team2') {
        color = teamConfig.team2?.displayColor || '#FFFFFF';
    } else if (team === 'referee') {
        color = teamConfig.referee?.displayColor || '#EC4899';
    } else {
        color = '#6B7280';
    }

    if (alpha < 1 && color.startsWith('#')) {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    return color;
}

function drawPositions(frameData) {
    playersOverlay.innerHTML = '';

    if (!frameData || !frameData.detections) return;

    // Trails zeichnen
    if (trailLength > 0) {
        for (const det of frameData.detections) {
            if (!det.track_id || !det.field_x || !det.field_y) continue;

            const history = positionHistory[det.track_id] || [];
            if (history.length >= 2) {
                const pathPoints = history.map(h => `${h.x},${FIELD_WIDTH - h.y}`).join(' ');
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', pathPoints);
                polyline.setAttribute('fill', 'none');
                polyline.setAttribute('stroke', getTeamColor(det.team, 0.4));
                polyline.setAttribute('stroke-width', '0.3');
                playersOverlay.appendChild(polyline);
            }
        }
    }

    // Spieler zeichnen
    for (const det of frameData.detections) {
        if (!det.field_x || !det.field_y) continue;

        const svgX = det.field_x;
        const svgY = FIELD_WIDTH - det.field_y;

        if (svgX < -1 || svgX > FIELD_LENGTH + 1 || svgY < -1 || svgY > FIELD_WIDTH + 1) continue;

        const color = getTeamColor(det.team);
        const radius = 0.6;

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', svgX);
        circle.setAttribute('cy', svgY);
        circle.setAttribute('r', radius);
        circle.setAttribute('fill', color);
        circle.setAttribute('stroke', 'white');
        circle.setAttribute('stroke-width', '0.1');
        playersOverlay.appendChild(circle);

        // Track-ID anzeigen
        if (det.track_id) {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', svgX);
            text.setAttribute('y', svgY + 0.15);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '0.4');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', 'white');
            text.textContent = det.track_id;
            playersOverlay.appendChild(text);
        }

        // Position History aktualisieren
        if (det.track_id) {
            if (!positionHistory[det.track_id]) {
                positionHistory[det.track_id] = [];
            }
            const history = positionHistory[det.track_id];
            if (history.length === 0 || history[history.length - 1].x !== det.field_x || history[history.length - 1].y !== det.field_y) {
                history.push({ x: det.field_x, y: det.field_y });
                while (history.length > trailLength) {
                    history.shift();
                }
            }
        }
    }
}

function drawVideoOverlay(frameData) {
    videoCtx.clearRect(0, 0, videoOverlay.width, videoOverlay.height);

    if (!showVideoOverlay || !frameData || !frameData.detections) return;

    for (const det of frameData.detections) {
        if (!det.bbox) continue;

        const [x1, y1, x2, y2] = det.bbox;
        const color = getTeamColor(det.team);

        videoCtx.strokeStyle = color;
        videoCtx.lineWidth = 3;
        videoCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);

        if (det.track_id) {
            videoCtx.font = 'bold 14px sans-serif';
            const text = `#${det.track_id}`;
            const textWidth = videoCtx.measureText(text).width;
            videoCtx.fillStyle = color;
            videoCtx.fillRect(x1, y1 - 20, textWidth + 8, 20);
            videoCtx.fillStyle = 'white';
            videoCtx.fillText(text, x1 + 4, y1 - 5);
        }
    }
}

function updateFrame() {
    const videoTime = video.currentTime;

    // Chunk finden
    const chunkIndex = findChunkForTime(videoTime);

    // Chunk-Anzeige aktualisieren
    document.querySelectorAll('.chunk-bar').forEach((bar, i) => {
        bar.classList.toggle('active', i === chunkIndex);
    });

    if (chunkIndex !== currentChunkIndex) {
        currentChunkIndex = chunkIndex;
        document.getElementById('currentChunk').textContent = chunkIndex >= 0 ? `${chunkIndex + 1}/${chunks.length}` : '-';
        preloadNearbyChunks(chunkIndex);
    }

    frameInfoEl.textContent = `Chunk: ${chunkIndex >= 0 ? chunkIndex + 1 : '-'}`;

    // Frame-Daten aus Chunk laden
    if (chunkIndex >= 0 && chunks[chunkIndex].loaded && chunks[chunkIndex].data) {
        const chunkData = chunks[chunkIndex].data;
        const localTime = videoTime - chunks[chunkIndex].start;

        // Frame finden
        let frameData = null;
        if (chunkData.frames) {
            for (const frame of chunkData.frames) {
                if (frame.timestamp <= localTime) {
                    frameData = frame;
                } else {
                    break;
                }
            }
        }

        drawPositions(frameData);
        drawVideoOverlay(frameData);
    } else {
        playersOverlay.innerHTML = '';
        videoCtx.clearRect(0, 0, videoOverlay.width, videoOverlay.height);
    }
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toFixed(1).padStart(4, '0')}`;
}

function updateTimeDisplay() {
    const current = video.currentTime;
    const duration = video.duration || 0;

    currentTimeEl.textContent = formatTime(current);
    durationEl.textContent = formatTime(duration);
    videoTimeEl.textContent = formatTime(current);

    const percent = duration > 0 ? (current / duration) * 100 : 0;
    timelineProgress.style.width = `${percent}%`;

    updateFrame();
}

// Event Listeners
video.addEventListener('timeupdate', updateTimeDisplay);
video.addEventListener('loadedmetadata', () => {
    updateTimeDisplay();
    setupOverlay();
    setupVideoOverlay();
});

document.getElementById('showVideoOverlay').addEventListener('change', (e) => {
    showVideoOverlay = e.target.checked;
    updateFrame();
});

playPauseBtn.addEventListener('click', () => {
    if (video.paused) {
        // Wenn Video außerhalb eines Chunks ist, zum ersten Chunk springen
        const currentChunk = findChunkForTime(video.currentTime);
        if (currentChunk < 0 && chunks.length > 0) {
            video.currentTime = chunks[0].start;
        }
        video.play();
        playPauseBtn.textContent = 'Pause';
    } else {
        video.pause();
        playPauseBtn.textContent = 'Play';
    }
});

// Automatisch zum nächsten Chunk springen wenn Video außerhalb eines Chunks läuft
video.addEventListener('timeupdate', () => {
    if (!video.paused) {
        const currentChunk = findChunkForTime(video.currentTime);
        if (currentChunk < 0) {
            // Video ist zwischen Chunks oder vor/nach allen Chunks
            // Finde nächsten Chunk
            for (let i = 0; i < chunks.length; i++) {
                if (chunks[i].start > video.currentTime) {
                    // Springe zum nächsten Chunk
                    video.currentTime = chunks[i].start;
                    return;
                }
            }
            // Kein weiterer Chunk, Video pausieren
            video.pause();
            playPauseBtn.textContent = 'Play';
        }
    }
});

timeline.addEventListener('click', (e) => {
    const rect = timeline.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    video.currentTime = percent * video.duration;
    positionHistory = {};
});

document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        video.playbackRate = parseFloat(btn.dataset.speed);
    });
});

trailLengthInput.addEventListener('input', (e) => {
    trailLength = parseInt(e.target.value);
    trailValueEl.textContent = trailLength;
    positionHistory = {};
    updateFrame();
});

document.addEventListener('keydown', (e) => {
    if (e.key === ' ' || e.key === 'k') {
        e.preventDefault();
        playPauseBtn.click();
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        video.currentTime = Math.max(0, video.currentTime - 1);
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        video.currentTime = Math.min(video.duration, video.currentTime + 1);
    }
});

window.addEventListener('resize', () => {
    setupOverlay();
    updateFrame();
});

// Initialize
setupOverlay();

// Ersten Chunk vorladen und Video auf Start setzen
if (chunks.length > 0) {
    loadChunkData(0);
    // Video auf ersten Chunk setzen wenn geladen
    video.addEventListener('loadedmetadata', () => {
        video.currentTime = chunks[0].start;
    }, { once: true });
}
</script>
{% endblock %}
