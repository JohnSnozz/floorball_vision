{% extends "base.html" %}

{% block title %}Schnelle Kalibrierung - {{ video.filename }}{% endblock %}

{% block head %}
<style>
    .canvas-container {
        position: relative;
        border: 2px solid #e5e7eb;
        border-radius: 8px;
        overflow: hidden;
        background: #f3f4f6;
    }
    .canvas-container canvas {
        display: block;
        cursor: crosshair;
    }
    .point-marker {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        border: 2px solid white;
        box-shadow: 0 0 4px rgba(0,0,0,0.5);
    }
    .point-label {
        position: absolute;
        transform: translate(-50%, -150%);
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 11px;
        white-space: nowrap;
        pointer-events: none;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-6">
    <!-- Header -->
    <div class="flex items-center justify-between mb-6">
        <div>
            <a href="{{ url_for('calibration.setup', video_id=video.id) }}" class="text-blue-500 hover:underline text-sm">
                &larr; Zurück zum Setup
            </a>
            <h1 class="text-2xl font-bold mt-2">Schnelle Kalibrierung</h1>
            <p class="text-gray-600">{{ video.filename or video.original_filename }}</p>
        </div>
        <div class="flex gap-2">
            <button onclick="clearAllPoints()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">
                Alle Punkte löschen
            </button>
            <button onclick="saveCalibration()" id="save-btn"
                    class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:bg-gray-400"
                    disabled>
                Kalibrierung speichern
            </button>
        </div>
    </div>

    <!-- Status -->
    <div id="status-bar" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
        <span id="status-text" class="text-blue-700">Klicke auf einen Punkt im Bild, dann auf den entsprechenden Punkt im Spielfeld.</span>
    </div>

    <!-- Main Grid -->
    <div class="grid grid-cols-2 gap-6">
        <!-- Linkes Panel: Bild -->
        <div>
            <div class="flex items-center justify-between mb-2">
                <h3 class="font-medium text-lg">Entzerrtes Bild</h3>
                <span id="image-point-count" class="text-sm text-gray-600 bg-gray-100 px-2 py-1 rounded">0 Punkte</span>
            </div>
            <div id="image-container" class="canvas-container">
                <canvas id="image-canvas"></canvas>
            </div>
            <p class="text-xs text-gray-500 mt-2">Klicke auf erkennbare Punkte (Ecken, Linien-Kreuzungen)</p>
        </div>

        <!-- Rechtes Panel: Spielfeld -->
        <div>
            <div class="flex items-center justify-between mb-2">
                <h3 class="font-medium text-lg">Spielfeld (40m × 20m)</h3>
                <span id="field-point-count" class="text-sm text-gray-600 bg-gray-100 px-2 py-1 rounded">0 Punkte</span>
            </div>
            <div id="field-container" class="canvas-container">
                <canvas id="field-canvas"></canvas>
            </div>
            <p class="text-xs text-gray-500 mt-2">Klicke auf die entsprechende Position im Spielfeld</p>
        </div>
    </div>

    <!-- Punkt-Paare Liste -->
    <div class="mt-6 bg-white rounded-lg shadow p-4">
        <h3 class="font-medium mb-3">Punkt-Paare (<span id="pair-count">0</span>/4 Minimum)</h3>
        <div id="point-pairs" class="flex flex-wrap gap-2">
            <span class="text-gray-400 text-sm">Noch keine Punkt-Paare definiert</span>
        </div>
    </div>

    <!-- Vorschau -->
    <div class="mt-6 bg-white rounded-lg shadow p-4">
        <div class="flex items-center justify-between mb-3">
            <h3 class="font-medium">Vorschau</h3>
            <button onclick="generatePreview()" id="preview-btn"
                    class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-400"
                    disabled>
                Vorschau generieren
            </button>
        </div>
        <div id="preview-container" class="border rounded-lg overflow-hidden bg-gray-100 min-h-[300px] flex items-center justify-center">
            <span class="text-gray-400">Mindestens 4 Punkt-Paare setzen, dann Vorschau generieren</span>
        </div>
    </div>

    <!-- Bekannte Spielfeld-Punkte Referenz -->
    <div class="mt-6 bg-gray-50 rounded-lg p-4">
        <h3 class="font-medium mb-2">Referenz: Spielfeld-Koordinaten</h3>
        <div class="grid grid-cols-4 gap-4 text-sm">
            <div>
                <strong>Ecken:</strong><br>
                (0, 0) - Links unten<br>
                (40, 0) - Rechts unten<br>
                (40, 20) - Rechts oben<br>
                (0, 20) - Links oben
            </div>
            <div>
                <strong>Mittellinie:</strong><br>
                (20, 0) - Mitte unten<br>
                (20, 20) - Mitte oben<br>
                (20, 10) - Mittelpunkt
            </div>
            <div>
                <strong>Tore (Mitte):</strong><br>
                (0, 10) - Linkes Tor<br>
                (40, 10) - Rechtes Tor
            </div>
            <div>
                <strong>Torraum-Ecken:</strong><br>
                (2.85, 5.5) - Linker Torraum<br>
                (2.85, 14.5)<br>
                (37.15, 5.5) - Rechter Torraum<br>
                (37.15, 14.5)
            </div>
        </div>
    </div>
</div>

<script>
const videoId = "{{ video.id }}";
const calibrationId = "{{ calibration.id if calibration else '' }}";

// Daten
let imagePoints = [];  // [{x, y}]
let fieldPoints = [];  // [{x, y}] in Metern
let pointPairs = [];   // [{image: {x,y}, field: {x,y}}]

// Canvas
let imageCanvas, imageCtx, fieldCanvas, fieldCtx;
let imageImg = null;

// Spielfeld-Dimensionen
const FIELD_WIDTH = 40;  // Meter
const FIELD_HEIGHT = 20; // Meter

// Bekannte Punkte auf dem Spielfeld für Snap-to
const KNOWN_POINTS = [
    // Ecken
    {x: 0, y: 0, label: "Ecke LU"},
    {x: 40, y: 0, label: "Ecke RU"},
    {x: 40, y: 20, label: "Ecke RO"},
    {x: 0, y: 20, label: "Ecke LO"},
    // Mittellinie
    {x: 20, y: 0, label: "Mitte U"},
    {x: 20, y: 20, label: "Mitte O"},
    {x: 20, y: 10, label: "Mittelpunkt"},
    // Tore
    {x: 0, y: 10, label: "Tor L"},
    {x: 40, y: 10, label: "Tor R"},
    // Mittelkreis (3m Radius)
    {x: 17, y: 10, label: "Kreis L"},
    {x: 23, y: 10, label: "Kreis R"},
    {x: 20, y: 7, label: "Kreis U"},
    {x: 20, y: 13, label: "Kreis O"},
    // Torraum links
    {x: 2.85, y: 5.5, label: "TRL UL"},
    {x: 2.85, y: 14.5, label: "TRL OL"},
    {x: 0, y: 5.5, label: "TRL U"},
    {x: 0, y: 14.5, label: "TRL O"},
    // Torraum rechts
    {x: 37.15, y: 5.5, label: "TRR UR"},
    {x: 37.15, y: 14.5, label: "TRR OR"},
    {x: 40, y: 5.5, label: "TRR U"},
    {x: 40, y: 14.5, label: "TRR O"},
];

document.addEventListener('DOMContentLoaded', init);

async function init() {
    imageCanvas = document.getElementById('image-canvas');
    imageCtx = imageCanvas.getContext('2d');
    fieldCanvas = document.getElementById('field-canvas');
    fieldCtx = fieldCanvas.getContext('2d');

    // Bild laden
    await loadImage();

    // Spielfeld zeichnen
    drawField();

    // Event Listeners
    imageCanvas.addEventListener('click', onImageClick);
    imageCanvas.addEventListener('contextmenu', (e) => { e.preventDefault(); removeLastPair(); });
    fieldCanvas.addEventListener('click', onFieldClick);
    fieldCanvas.addEventListener('contextmenu', (e) => { e.preventDefault(); removeLastPair(); });

    // Bestehende Kalibrierung laden
    await loadExistingCalibration();
}

async function loadImage() {
    return new Promise((resolve) => {
        imageImg = new Image();
        imageImg.onload = () => {
            // Canvas an Bildgröße anpassen (mit max Breite)
            const maxWidth = document.getElementById('image-container').clientWidth;
            const scale = Math.min(1, maxWidth / imageImg.width);

            imageCanvas.width = imageImg.width * scale;
            imageCanvas.height = imageImg.height * scale;

            // Skalierung speichern
            imageCanvas.dataset.scale = scale;
            imageCanvas.dataset.origWidth = imageImg.width;
            imageCanvas.dataset.origHeight = imageImg.height;

            drawImage();
            resolve();
        };
        imageImg.onerror = () => {
            console.error('Bild konnte nicht geladen werden');
            resolve();
        };
        // Versuche entzerrtes Bild, sonst Original
        imageImg.src = `/calibration/screenshot/${videoId}/undistorted_frame.jpg?t=${Date.now()}`;
    });
}

function drawImage() {
    if (!imageImg) return;

    const scale = parseFloat(imageCanvas.dataset.scale) || 1;
    imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
    imageCtx.drawImage(imageImg, 0, 0, imageCanvas.width, imageCanvas.height);

    // Punkte zeichnen
    pointPairs.forEach((pair, i) => {
        const x = pair.image.x * scale;
        const y = pair.image.y * scale;

        imageCtx.beginPath();
        imageCtx.arc(x, y, 8, 0, Math.PI * 2);
        imageCtx.fillStyle = getColor(i);
        imageCtx.fill();
        imageCtx.strokeStyle = 'white';
        imageCtx.lineWidth = 2;
        imageCtx.stroke();

        // Label
        imageCtx.fillStyle = 'white';
        imageCtx.font = 'bold 12px sans-serif';
        imageCtx.textAlign = 'center';
        imageCtx.fillText((i + 1).toString(), x, y + 4);
    });

    // Temporärer Punkt (noch kein Paar)
    if (imagePoints.length > pointPairs.length) {
        const pt = imagePoints[imagePoints.length - 1];
        const x = pt.x * scale;
        const y = pt.y * scale;

        imageCtx.beginPath();
        imageCtx.arc(x, y, 10, 0, Math.PI * 2);
        imageCtx.strokeStyle = '#f59e0b';
        imageCtx.lineWidth = 3;
        imageCtx.stroke();
        imageCtx.setLineDash([5, 5]);
        imageCtx.stroke();
        imageCtx.setLineDash([]);
    }
}

function drawField() {
    const container = document.getElementById('field-container');
    const maxWidth = container.clientWidth;
    const aspectRatio = FIELD_WIDTH / FIELD_HEIGHT;

    fieldCanvas.width = maxWidth;
    fieldCanvas.height = maxWidth / aspectRatio;

    const ctx = fieldCtx;
    const w = fieldCanvas.width;
    const h = fieldCanvas.height;
    const padding = 20;

    // Skalierung
    const scaleX = (w - 2 * padding) / FIELD_WIDTH;
    const scaleY = (h - 2 * padding) / FIELD_HEIGHT;

    fieldCanvas.dataset.scaleX = scaleX;
    fieldCanvas.dataset.scaleY = scaleY;
    fieldCanvas.dataset.padding = padding;

    // Hintergrund
    ctx.fillStyle = '#1e40af';
    ctx.fillRect(0, 0, w, h);

    // Spielfeld
    ctx.fillStyle = '#3b82f6';
    ctx.fillRect(padding, padding, w - 2 * padding, h - 2 * padding);

    // Linien
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;

    // Spielfeldrand
    ctx.strokeRect(padding, padding, w - 2 * padding, h - 2 * padding);

    // Mittellinie
    ctx.beginPath();
    ctx.moveTo(padding + scaleX * 20, padding);
    ctx.lineTo(padding + scaleX * 20, h - padding);
    ctx.stroke();

    // Mittelkreis (3m Radius)
    ctx.beginPath();
    ctx.arc(padding + scaleX * 20, padding + scaleY * 10, scaleX * 3, 0, Math.PI * 2);
    ctx.stroke();

    // Torräume (halbrund)
    // Links
    ctx.beginPath();
    ctx.arc(padding, padding + scaleY * 10, scaleX * 2.85, -Math.PI/2, Math.PI/2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(padding, padding + scaleY * 5.5);
    ctx.lineTo(padding + scaleX * 2.85, padding + scaleY * 5.5);
    ctx.moveTo(padding, padding + scaleY * 14.5);
    ctx.lineTo(padding + scaleX * 2.85, padding + scaleY * 14.5);
    ctx.stroke();

    // Rechts
    ctx.beginPath();
    ctx.arc(w - padding, padding + scaleY * 10, scaleX * 2.85, Math.PI/2, -Math.PI/2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w - padding, padding + scaleY * 5.5);
    ctx.lineTo(w - padding - scaleX * 2.85, padding + scaleY * 5.5);
    ctx.moveTo(w - padding, padding + scaleY * 14.5);
    ctx.lineTo(w - padding - scaleX * 2.85, padding + scaleY * 14.5);
    ctx.stroke();

    // Bekannte Punkte zeichnen
    KNOWN_POINTS.forEach(pt => {
        const x = padding + pt.x * scaleX;
        const y = padding + (FIELD_HEIGHT - pt.y) * scaleY;  // Y invertiert

        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fill();
    });

    // Gesetzte Punkte
    pointPairs.forEach((pair, i) => {
        const x = padding + pair.field.x * scaleX;
        const y = padding + (FIELD_HEIGHT - pair.field.y) * scaleY;

        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fillStyle = getColor(i);
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText((i + 1).toString(), x, y + 4);
    });

    // Temporärer Bildpunkt wartet auf Spielfeld-Punkt
    if (imagePoints.length > pointPairs.length) {
        ctx.fillStyle = 'rgba(245, 158, 11, 0.3)';
        ctx.fillRect(padding, padding, w - 2 * padding, h - 2 * padding);
    }
}

function getColor(index) {
    const colors = ['#ef4444', '#22c55e', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];
    return colors[index % colors.length];
}

function onImageClick(e) {
    const rect = imageCanvas.getBoundingClientRect();
    const scale = parseFloat(imageCanvas.dataset.scale) || 1;

    // Koordinaten im Originalbild
    const x = (e.clientX - rect.left) / scale;
    const y = (e.clientY - rect.top) / scale;

    imagePoints.push({x, y});
    updateStatus('Jetzt klicke auf die entsprechende Position im Spielfeld');
    redraw();
}

function onFieldClick(e) {
    if (imagePoints.length <= pointPairs.length) {
        updateStatus('Zuerst einen Punkt im Bild setzen!', 'warning');
        return;
    }

    const rect = fieldCanvas.getBoundingClientRect();
    const scaleX = parseFloat(fieldCanvas.dataset.scaleX);
    const scaleY = parseFloat(fieldCanvas.dataset.scaleY);
    const padding = parseFloat(fieldCanvas.dataset.padding);

    let x = (e.clientX - rect.left - padding) / scaleX;
    let y = FIELD_HEIGHT - (e.clientY - rect.top - padding) / scaleY;  // Y invertiert

    // Snap zu bekannten Punkten (Toleranz 1m)
    const snapDist = 1.0;
    for (const pt of KNOWN_POINTS) {
        const dist = Math.sqrt((x - pt.x) ** 2 + (y - pt.y) ** 2);
        if (dist < snapDist) {
            x = pt.x;
            y = pt.y;
            break;
        }
    }

    // Begrenzen auf Spielfeld
    x = Math.max(0, Math.min(FIELD_WIDTH, x));
    y = Math.max(0, Math.min(FIELD_HEIGHT, y));

    fieldPoints.push({x, y});

    // Paar erstellen
    const imgPt = imagePoints[imagePoints.length - 1];
    pointPairs.push({
        image: imgPt,
        field: {x, y}
    });

    updateStatus(`Punkt-Paar ${pointPairs.length} gesetzt. Weiter mit dem nächsten Punkt.`);
    redraw();
    updateUI();
}

function removeLastPair() {
    if (pointPairs.length > 0) {
        pointPairs.pop();
        imagePoints.pop();
        fieldPoints.pop();
        redraw();
        updateUI();
        updateStatus('Letztes Punkt-Paar entfernt');
    }
}

function clearAllPoints() {
    pointPairs = [];
    imagePoints = [];
    fieldPoints = [];
    redraw();
    updateUI();
    updateStatus('Alle Punkte gelöscht');
}

function redraw() {
    drawImage();
    drawField();
}

function updateUI() {
    const count = pointPairs.length;

    document.getElementById('image-point-count').textContent = `${count} Punkte`;
    document.getElementById('field-point-count').textContent = `${count} Punkte`;
    document.getElementById('pair-count').textContent = count;

    // Buttons aktivieren/deaktivieren
    document.getElementById('preview-btn').disabled = count < 4;
    document.getElementById('save-btn').disabled = count < 4;

    // Punkt-Paare Liste
    const container = document.getElementById('point-pairs');
    if (count === 0) {
        container.innerHTML = '<span class="text-gray-400 text-sm">Noch keine Punkt-Paare definiert</span>';
    } else {
        container.innerHTML = pointPairs.map((pair, i) => `
            <div class="flex items-center gap-2 bg-gray-100 px-3 py-2 rounded cursor-pointer hover:bg-red-100"
                 onclick="removePair(${i})" title="Klicken zum Entfernen">
                <span class="w-6 h-6 rounded-full flex items-center justify-center text-white text-sm font-bold"
                      style="background: ${getColor(i)}">${i + 1}</span>
                <span class="text-sm">
                    Bild: (${Math.round(pair.image.x)}, ${Math.round(pair.image.y)})
                    → Feld: (${pair.field.x.toFixed(1)}, ${pair.field.y.toFixed(1)})m
                </span>
            </div>
        `).join('');
    }
}

function removePair(index) {
    pointPairs.splice(index, 1);
    imagePoints.splice(index, 1);
    fieldPoints.splice(index, 1);
    redraw();
    updateUI();
}

function updateStatus(text, type = 'info') {
    const bar = document.getElementById('status-bar');
    const textEl = document.getElementById('status-text');

    textEl.textContent = text;

    bar.className = 'mb-4 p-3 border rounded-lg';
    if (type === 'warning') {
        bar.classList.add('bg-yellow-50', 'border-yellow-200');
        textEl.className = 'text-yellow-700';
    } else if (type === 'success') {
        bar.classList.add('bg-green-50', 'border-green-200');
        textEl.className = 'text-green-700';
    } else {
        bar.classList.add('bg-blue-50', 'border-blue-200');
        textEl.className = 'text-blue-700';
    }
}

async function generatePreview() {
    if (pointPairs.length < 4) {
        updateStatus('Mindestens 4 Punkt-Paare erforderlich', 'warning');
        return;
    }

    updateStatus('Generiere Vorschau...');

    try {
        const response = await fetch(`/calibration/api/videos/${videoId}/calibration/preview`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                point_pairs: pointPairs,
                use_undistorted: true
            })
        });

        const result = await response.json();

        if (result.success) {
            const container = document.getElementById('preview-container');
            container.innerHTML = `<img src="/calibration/screenshot/${videoId}/test_overlay.jpg?t=${Date.now()}"
                                        class="max-w-full" alt="Vorschau">`;
            updateStatus('Vorschau generiert! Prüfe ob die Linien passen.', 'success');
        } else {
            updateStatus('Fehler: ' + result.error, 'warning');
        }
    } catch (err) {
        updateStatus('Fehler: ' + err.message, 'warning');
    }
}

async function saveCalibration() {
    if (pointPairs.length < 4) {
        updateStatus('Mindestens 4 Punkt-Paare erforderlich', 'warning');
        return;
    }

    updateStatus('Speichere Kalibrierung...');

    try {
        const response = await fetch(`/calibration/api/videos/${videoId}/calibration/save`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                point_pairs: pointPairs,
                use_undistorted: true,
                lens_profile_id: null  // Bereits entzerrt
            })
        });

        const result = await response.json();

        if (result.success) {
            updateStatus('Kalibrierung erfolgreich gespeichert!', 'success');
            document.getElementById('save-btn').textContent = '✓ Gespeichert';
        } else {
            updateStatus('Fehler beim Speichern: ' + result.error, 'warning');
        }
    } catch (err) {
        updateStatus('Fehler: ' + err.message, 'warning');
    }
}

async function loadExistingCalibration() {
    try {
        const response = await fetch(`/calibration/api/videos/${videoId}/calibration`);
        const result = await response.json();

        if (result.success && result.calibration_data) {
            const data = result.calibration_data;

            // Punkt-Paare laden wenn vorhanden
            if (data.point_pairs && data.point_pairs.length > 0) {
                pointPairs = data.point_pairs;
                imagePoints = pointPairs.map(p => p.image);
                fieldPoints = pointPairs.map(p => p.field);

                redraw();
                updateUI();
                updateStatus(`${pointPairs.length} Punkt-Paare aus bestehender Kalibrierung geladen`);
            }
        }
    } catch (err) {
        console.log('Keine bestehende Kalibrierung gefunden');
    }
}
</script>
{% endblock %}
